; gerb comments
;   ; comment

; gerb token/terminal synstax
;   'terminal' = "exact-match"
;   'terminal' = [allowed chars]
;   'terminal' = "more"* | [complicated]+ "expression"?
;   'match-any' = .
;   'terminal' = "\n" | "\\n"
;   ALL_CAPS   = [captures what it matches]
;   ''        = "ignore"
; possible errors
;   two terminals starting with some overlap in characters (could be fixed)
;   two options in an or having an overlap in characters
;   the first element of every option of the first or must not be optional (could be fixed)
;   some repeating postfix being followed by something thats a subset of whats repeating (e.g, "\"" .* "\"". . includes ") (actually allowed, just doesnt do what i/you want)
;   two terminals with the same name (may be changed)

'('  = "("
')'  = ")"
'='  = "="
'|'  = "|"
'*'  = "*"
'+'  = "+"
'?'  = "?"
'!'  = "!"
'.'  = "."
'eof'= "\0"
'\n' = "\n"
''  = [ \t]+ | ( ";" .* "\n" )
EXACT        = "\"" !"\""+ "\""
UNION        = "[" !"]"+ "]"
NON_TERMINAL = [abcdefghijklmnopqrstuvwxyz-]+
TERMINAL     = ("'" !"'"* "'") | [ABCDEFGHIJKLMNOPQRSTUVWXYZ_]+

; switch ( code[begin] ) {
;   struct token token;
;   case '\'' :
;       break;
;   case 'A': case 'B': case 'C': ...
;       break;
; }

; gerb rules syntax
;   non-terminal = non-terminal
;   non-terminal = 'terminal'
;   non-terminal = 'or-option-1' | 'or-option-2' | or-option-3
;   non-terminal = 'terminal'*
; gerb precedence
;   ()
;   * ? +
;   |
; possible errors
;   two rules with the same name
;   a repeating/optional part of a rule sometimes being able to be matched by another rule (e.g, a = b b*. b* can be matched by a) (error could be made stricter)
;   a rule that is used in multiple other rules being used without other non-optional parts which arent in the other rules

gerb = ( ( token '\n' ) | ( rule '\n' ) | '\n' )* 'eof'

; terminal rules
token         = TERMINAL '=' token-expr
token-expr    = token-or+
token-or      = token-postfix ( '|' token-postfix )*
token-postfix = token-prefix ( '*' | '+' | '?' )?
token-prefix  = '!'? token-primary
token-primary = ( '(' token-expr ')' ) | EXACT | UNION | '.'

; non-terminal rules
rule         =   NON_TERMINAL '=' rule-expr
rule-expr    =   rule-or+
rule-or      =   rule-postfix ( '|' rule-postfix )*
rule-postfix =   rule-primary ( '*' | '+' | '?' )?
rule-primary =   NON_TERMINAL | TERMINAL | ( '(' rule-expr ')' )
